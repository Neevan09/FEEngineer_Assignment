'use strict';

var _reactRouterDom = require('react-router-dom');

var _effects = require('redux-saga/effects');

var _enzyme = require('enzyme');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _configureStore = require('./configureStore');

var _configureStore2 = _interopRequireDefault(_configureStore);

var _injectSaga = require('../injectSaga');

var _injectSaga2 = _interopRequireDefault(_injectSaga);

var _sagaInjectors = require('../sagaInjectors');

var sagaInjectors = _interopRequireWildcard(_sagaInjectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = /*#__PURE__*/regeneratorRuntime.mark(testSaga); /**
                                                               * Test injectors
                                                               */

// Fixtures
var Component = function Component() {
  return null;
};

function testSaga() {
  return regeneratorRuntime.wrap(function testSaga$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _effects.put)({ type: 'TEST', payload: 'yup' });

        case 2:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked, this);
}

describe('injectSaga decorator', function () {
  var store = void 0;
  var injectors = void 0;
  var ComponentWithSaga = void 0;

  beforeAll(function () {
    sagaInjectors.default = jest.fn().mockImplementation(function () {
      return injectors;
    });
  });

  beforeEach(function () {
    store = (0, _configureStore2.default)({}, _reactRouterDom.memoryHistory);
    injectors = {
      injectSaga: jest.fn(),
      ejectSaga: jest.fn()
    };
    ComponentWithSaga = (0, _injectSaga2.default)({ key: 'test', saga: testSaga, mode: 'testMode' })(Component);
    sagaInjectors.default.mockClear();
  });

  it('should inject given saga, mode, and props', function () {
    var props = { test: 'test' };
    (0, _enzyme.shallow)(_react2.default.createElement(ComponentWithSaga, props), { context: { store: store } });

    expect(injectors.injectSaga).toHaveBeenCalledTimes(1);
    expect(injectors.injectSaga).toHaveBeenCalledWith('test', { saga: testSaga, mode: 'testMode' }, props);
  });

  it('should eject on unmount with a correct saga key', function () {
    var props = { test: 'test' };
    var renderedComponent = (0, _enzyme.shallow)(_react2.default.createElement(ComponentWithSaga, props), { context: { store: store } });
    renderedComponent.unmount();

    expect(injectors.ejectSaga).toHaveBeenCalledTimes(1);
    expect(injectors.ejectSaga).toHaveBeenCalledWith('test');
  });

  it('should set a correct display name', function () {
    expect(ComponentWithSaga.displayName).toBe('withSaga(Component)');
    expect((0, _injectSaga2.default)({ key: 'test', saga: testSaga })(function () {
      return null;
    }).displayName).toBe('withSaga(Component)');
  });

  it('should propagate props', function () {
    var props = { testProp: 'test' };
    var renderedComponent = (0, _enzyme.shallow)(_react2.default.createElement(ComponentWithSaga, props), { context: { store: store } });

    expect(renderedComponent.prop('testProp')).toBe('test');
  });
});