'use strict';

var _reactRouterDom = require('react-router-dom');

var _effects = require('redux-saga/effects');

var _configureStore = require('./configureStore');

var _configureStore2 = _interopRequireDefault(_configureStore);

var _sagaInjectors = require('../sagaInjectors');

var _sagaInjectors2 = _interopRequireDefault(_sagaInjectors);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _marked = /*#__PURE__*/regeneratorRuntime.mark(testSaga); /**
                                                               * Test injectors
                                                               */

function testSaga() {
  return regeneratorRuntime.wrap(function testSaga$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _effects.put)({ type: 'TEST', payload: 'yup' });

        case 2:
        case 'end':
          return _context.stop();
      }
    }
  }, _marked, this);
}

describe('injectors', function () {
  var originalNodeEnv = process.env.NODE_ENV;
  var store = void 0;
  var injectSaga = void 0;
  var ejectSaga = void 0;

  describe('getInjectors', function () {
    beforeEach(function () {
      store = (0, _configureStore2.default)({}, _reactRouterDom.memoryHistory);
    });

    it('should return injectors', function () {
      expect((0, _sagaInjectors2.default)(store)).toEqual(expect.objectContaining({
        injectSaga: expect.any(Function),
        ejectSaga: expect.any(Function)
      }));
    });

    // it('should throw if passed invalid store shape', () => {
    //   Reflect.deleteProperty(store, 'dispatch');
    //
    //   expect(() => getInjectors(store)).toThrow();
    // });
  });

  describe('ejectSaga helper', function () {
    beforeEach(function () {
      store = (0, _configureStore2.default)({}, _reactRouterDom.memoryHistory);
      injectSaga = (0, _sagaInjectors.injectSagaFactory)(store, true);
      ejectSaga = (0, _sagaInjectors.ejectSagaFactory)(store, true);
    });

    it('should check a store if the second argument is falsy', function () {
      var eject = (0, _sagaInjectors.ejectSagaFactory)({});

      expect(function () {
        return eject('test');
      }).toThrow();
    });

    it('should not check a store if the second argument is true', function () {
      Reflect.deleteProperty(store, 'dispatch');
      injectSaga('test', { saga: testSaga });

      expect(function () {
        return ejectSaga('test');
      }).not.toThrow();
    });

    it('should validate saga\'s key', function () {
      expect(function () {
        return ejectSaga('');
      }).toThrow();
      expect(function () {
        return ejectSaga(1);
      }).toThrow();
    });

    it('should cancel a saga in a default mode', function () {
      var cancel = jest.fn();
      store.injectedSagas.test = { task: { cancel: cancel } };
      ejectSaga('test');

      expect(cancel).toHaveBeenCalled();
    });

    it('should not cancel a daemon saga', function () {
      var cancel = jest.fn();
      store.injectedSagas.test = { task: { cancel: cancel }, mode: _constants.DAEMON };
      ejectSaga('test');

      expect(cancel).not.toHaveBeenCalled();
    });

    it('should ignore saga that was not previously injected', function () {
      expect(function () {
        return ejectSaga('test');
      }).not.toThrow();
    });

    it('should remove non daemon saga\'s descriptor in production', function () {
      process.env.NODE_ENV = 'production';
      injectSaga('test', { saga: testSaga, mode: _constants.RESTART_ON_REMOUNT });
      injectSaga('test1', { saga: testSaga, mode: _constants.ONCE_TILL_UNMOUNT });

      ejectSaga('test');
      ejectSaga('test1');

      expect(store.injectedSagas.test).toBe('done');
      expect(store.injectedSagas.test1).toBe('done');
      process.env.NODE_ENV = originalNodeEnv;
    });

    it('should not remove daemon saga\'s descriptor in production', function () {
      process.env.NODE_ENV = 'production';
      injectSaga('test', { saga: testSaga, mode: _constants.DAEMON });
      ejectSaga('test');

      expect(store.injectedSagas.test.saga).toBe(testSaga);
      process.env.NODE_ENV = originalNodeEnv;
    });

    it('should not remove daemon saga\'s descriptor in development', function () {
      injectSaga('test', { saga: testSaga, mode: _constants.DAEMON });
      ejectSaga('test');

      expect(store.injectedSagas.test.saga).toBe(testSaga);
    });
  });

  describe('injectSaga helper', function () {
    beforeEach(function () {
      store = (0, _configureStore2.default)({}, _reactRouterDom.memoryHistory);
      injectSaga = (0, _sagaInjectors.injectSagaFactory)(store, true);
      ejectSaga = (0, _sagaInjectors.ejectSagaFactory)(store, true);
    });

    it('should check a store if the second argument is falsy', function () {
      var inject = (0, _sagaInjectors.injectSagaFactory)({});

      expect(function () {
        return inject('test', testSaga);
      }).toThrow();
    });

    it('it should not check a store if the second argument is true', function () {
      Reflect.deleteProperty(store, 'dispatch');

      expect(function () {
        return injectSaga('test', { saga: testSaga });
      }).not.toThrow();
    });

    it('should validate saga\'s key', function () {
      expect(function () {
        return injectSaga('', { saga: testSaga });
      }).toThrow();
      expect(function () {
        return injectSaga(1, { saga: testSaga });
      }).toThrow();
    });

    it('should validate saga\'s descriptor', function () {
      expect(function () {
        return injectSaga('test');
      }).toThrow();
      expect(function () {
        return injectSaga('test', { saga: 1 });
      }).toThrow();
      expect(function () {
        return injectSaga('test', { saga: testSaga, mode: 'testMode' });
      }).toThrow();
      expect(function () {
        return injectSaga('test', { saga: testSaga, mode: 1 });
      }).toThrow();
      expect(function () {
        return injectSaga('test', { saga: testSaga, mode: _constants.RESTART_ON_REMOUNT });
      }).not.toThrow();
      expect(function () {
        return injectSaga('test', { saga: testSaga, mode: _constants.DAEMON });
      }).not.toThrow();
      expect(function () {
        return injectSaga('test', { saga: testSaga, mode: _constants.ONCE_TILL_UNMOUNT });
      }).not.toThrow();
    });

    it('should pass args to saga.run', function () {
      var args = {};
      store.runSaga = jest.fn();
      injectSaga('test', { saga: testSaga }, args);

      expect(store.runSaga).toHaveBeenCalledWith(testSaga, args);
    });

    it('should not start daemon and once-till-unmount sagas if were started before', function () {
      store.runSaga = jest.fn();

      injectSaga('test1', { saga: testSaga, mode: _constants.DAEMON });
      injectSaga('test1', { saga: testSaga, mode: _constants.DAEMON });
      injectSaga('test2', { saga: testSaga, mode: _constants.ONCE_TILL_UNMOUNT });
      injectSaga('test2', { saga: testSaga, mode: _constants.ONCE_TILL_UNMOUNT });

      expect(store.runSaga).toHaveBeenCalledTimes(2);
    });

    it('should start any saga that was not started before', function () {
      store.runSaga = jest.fn();

      injectSaga('test1', { saga: testSaga });
      injectSaga('test2', { saga: testSaga, mode: _constants.DAEMON });
      injectSaga('test3', { saga: testSaga, mode: _constants.ONCE_TILL_UNMOUNT });

      expect(store.runSaga).toHaveBeenCalledTimes(3);
    });

    it('should restart a saga if different implementation for hot reloading', function () {
      var _marked2 = /*#__PURE__*/regeneratorRuntime.mark(testSaga1);

      var cancel = jest.fn();
      store.injectedSagas.test = { saga: testSaga, task: { cancel: cancel } };
      store.runSaga = jest.fn();

      function testSaga1() {
        return regeneratorRuntime.wrap(function testSaga1$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return (0, _effects.put)({ type: 'TEST', payload: 'yup' });

              case 2:
              case 'end':
                return _context2.stop();
            }
          }
        }, _marked2, this);
      }

      injectSaga('test', { saga: testSaga1 });

      expect(cancel).toHaveBeenCalledTimes(1);
      expect(store.runSaga).toHaveBeenCalledWith(testSaga1, undefined);
    });

    it('should not cancel saga if different implementation in production', function () {
      var _marked3 = /*#__PURE__*/regeneratorRuntime.mark(testSaga1);

      process.env.NODE_ENV = 'production';
      var cancel = jest.fn();
      store.injectedSagas.test = { saga: testSaga, task: { cancel: cancel }, mode: _constants.RESTART_ON_REMOUNT };

      function testSaga1() {
        return regeneratorRuntime.wrap(function testSaga1$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return (0, _effects.put)({ type: 'TEST', payload: 'yup' });

              case 2:
              case 'end':
                return _context3.stop();
            }
          }
        }, _marked3, this);
      }

      injectSaga('test', { saga: testSaga1, mode: _constants.DAEMON });

      expect(cancel).toHaveBeenCalledTimes(0);
      process.env.NODE_ENV = originalNodeEnv;
    });

    it('should save an entire descriptor in the saga registry', function () {
      injectSaga('test', { saga: testSaga, foo: 'bar' });
      expect(store.injectedSagas.test.foo).toBe('bar');
    });
  });
});