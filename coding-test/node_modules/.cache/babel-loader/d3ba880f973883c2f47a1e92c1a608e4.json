{"ast":null,"code":"import invariant from 'invariant';\nimport { isEmpty, isFunction, isString, conformsTo } from 'lodash';\nimport checkStore from './checkStore';\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants';\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\n\nconst checkKey = key => invariant(isString(key) && !isEmpty(key), '(app/utils...) injectSaga: Expected `key` to be a non empty string');\n\nconst checkDescriptor = descriptor => {\n  const shape = {\n    saga: isFunction,\n    mode: mode => isString(mode) && allowedModes.includes(mode)\n  };\n  invariant(conformsTo(descriptor, shape), '(app/utils...) injectSaga: Expected a valid saga descriptor');\n};\n\nexport function injectSagaFactory(store, isValid) {\n  return function injectSaga(key, descriptor = {}, args) {\n    if (!isValid) checkStore(store);\n    const newDescriptor = { ...descriptor,\n      mode: descriptor.mode || DAEMON\n    };\n    const {\n      saga,\n      mode\n    } = newDescriptor;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    let hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (!hasSaga || hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT) {\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key] = { ...newDescriptor,\n        task: store.runSaga(saga, args)\n      };\n      /* eslint-enable no-param-reassign */\n    }\n  };\n}\nexport function ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key];\n\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\nexport default function getInjectors(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}","map":{"version":3,"sources":["C:/Users/Naveen/Desktop/Final/FEEngineer_Assignment/coding-test/src/utils/sagaInjectors.js"],"names":["invariant","isEmpty","isFunction","isString","conformsTo","checkStore","DAEMON","ONCE_TILL_UNMOUNT","RESTART_ON_REMOUNT","allowedModes","checkKey","key","checkDescriptor","descriptor","shape","saga","mode","includes","injectSagaFactory","store","isValid","injectSaga","args","newDescriptor","hasSaga","Reflect","has","injectedSagas","process","env","NODE_ENV","oldDescriptor","task","cancel","runSaga","ejectSagaFactory","ejectSaga","getInjectors"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,WAAtB;AACA,SAASC,OAAT,EAAkBC,UAAlB,EAA8BC,QAA9B,EAAwCC,UAAxC,QAA0D,QAA1D;AAEA,OAAOC,UAAP,MAAuB,cAAvB;AACA,SAASC,MAAT,EAAiBC,iBAAjB,EAAoCC,kBAApC,QAA8D,aAA9D;AAEA,MAAMC,YAAY,GAAG,CAACD,kBAAD,EAAqBF,MAArB,EAA6BC,iBAA7B,CAArB;;AAEA,MAAMG,QAAQ,GAAGC,GAAG,IAClBX,SAAS,CACPG,QAAQ,CAACQ,GAAD,CAAR,IAAiB,CAACV,OAAO,CAACU,GAAD,CADlB,EAEP,oEAFO,CADX;;AAMA,MAAMC,eAAe,GAAGC,UAAU,IAAI;AACpC,QAAMC,KAAK,GAAG;AACZC,IAAAA,IAAI,EAAEb,UADM;AAEZc,IAAAA,IAAI,EAAEA,IAAI,IAAIb,QAAQ,CAACa,IAAD,CAAR,IAAkBP,YAAY,CAACQ,QAAb,CAAsBD,IAAtB;AAFpB,GAAd;AAIAhB,EAAAA,SAAS,CACPI,UAAU,CAACS,UAAD,EAAaC,KAAb,CADH,EAEP,6DAFO,CAAT;AAID,CATD;;AAWA,OAAO,SAASI,iBAAT,CAA2BC,KAA3B,EAAkCC,OAAlC,EAA2C;AAChD,SAAO,SAASC,UAAT,CAAoBV,GAApB,EAAyBE,UAAU,GAAG,EAAtC,EAA0CS,IAA1C,EAAgD;AACrD,QAAI,CAACF,OAAL,EAAcf,UAAU,CAACc,KAAD,CAAV;AAEd,UAAMI,aAAa,GAAG,EACpB,GAAGV,UADiB;AAEpBG,MAAAA,IAAI,EAAEH,UAAU,CAACG,IAAX,IAAmBV;AAFL,KAAtB;AAIA,UAAM;AAAES,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAiBO,aAAvB;AAEAb,IAAAA,QAAQ,CAACC,GAAD,CAAR;AACAC,IAAAA,eAAe,CAACW,aAAD,CAAf;AAEA,QAAIC,OAAO,GAAGC,OAAO,CAACC,GAAR,CAAYP,KAAK,CAACQ,aAAlB,EAAiChB,GAAjC,CAAd;;AAEA,QAAIiB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,YAAMC,aAAa,GAAGZ,KAAK,CAACQ,aAAN,CAAoBhB,GAApB,CAAtB,CADyC,CAEzC;;AACA,UAAIa,OAAO,IAAIO,aAAa,CAAChB,IAAd,KAAuBA,IAAtC,EAA4C;AAC1CgB,QAAAA,aAAa,CAACC,IAAd,CAAmBC,MAAnB;AACAT,QAAAA,OAAO,GAAG,KAAV;AACD;AACF;;AAED,QACE,CAACA,OAAD,IACCA,OAAO,IAAIR,IAAI,KAAKV,MAApB,IAA8BU,IAAI,KAAKT,iBAF1C,EAGE;AACA;AACAY,MAAAA,KAAK,CAACQ,aAAN,CAAoBhB,GAApB,IAA2B,EACzB,GAAGY,aADsB;AAEzBS,QAAAA,IAAI,EAAEb,KAAK,CAACe,OAAN,CAAcnB,IAAd,EAAoBO,IAApB;AAFmB,OAA3B;AAIA;AACD;AACF,GAlCD;AAmCD;AAED,OAAO,SAASa,gBAAT,CAA0BhB,KAA1B,EAAiCC,OAAjC,EAA0C;AAC/C,SAAO,SAASgB,SAAT,CAAmBzB,GAAnB,EAAwB;AAC7B,QAAI,CAACS,OAAL,EAAcf,UAAU,CAACc,KAAD,CAAV;AAEdT,IAAAA,QAAQ,CAACC,GAAD,CAAR;;AAEA,QAAIc,OAAO,CAACC,GAAR,CAAYP,KAAK,CAACQ,aAAlB,EAAiChB,GAAjC,CAAJ,EAA2C;AACzC,YAAME,UAAU,GAAGM,KAAK,CAACQ,aAAN,CAAoBhB,GAApB,CAAnB;;AACA,UAAIE,UAAU,CAACG,IAAX,IAAmBH,UAAU,CAACG,IAAX,KAAoBV,MAA3C,EAAmD;AACjDO,QAAAA,UAAU,CAACmB,IAAX,CAAgBC,MAAhB,GADiD,CAEjD;;AACA,YAAIL,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACAX,UAAAA,KAAK,CAACQ,aAAN,CAAoBhB,GAApB,IAA2B,MAA3B,CAFyC,CAEN;AACpC;AACF;AACF;AACF,GAhBD;AAiBD;AAED,eAAe,SAAS0B,YAAT,CAAsBlB,KAAtB,EAA6B;AAC1Cd,EAAAA,UAAU,CAACc,KAAD,CAAV;AAEA,SAAO;AACLE,IAAAA,UAAU,EAAEH,iBAAiB,CAACC,KAAD,EAAQ,IAAR,CADxB;AAELiB,IAAAA,SAAS,EAAED,gBAAgB,CAAChB,KAAD,EAAQ,IAAR;AAFtB,GAAP;AAID","sourcesContent":["import invariant from 'invariant';\r\nimport { isEmpty, isFunction, isString, conformsTo } from 'lodash';\r\n\r\nimport checkStore from './checkStore';\r\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants';\r\n\r\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\r\n\r\nconst checkKey = key =>\r\n  invariant(\r\n    isString(key) && !isEmpty(key),\r\n    '(app/utils...) injectSaga: Expected `key` to be a non empty string',\r\n  );\r\n\r\nconst checkDescriptor = descriptor => {\r\n  const shape = {\r\n    saga: isFunction,\r\n    mode: mode => isString(mode) && allowedModes.includes(mode),\r\n  };\r\n  invariant(\r\n    conformsTo(descriptor, shape),\r\n    '(app/utils...) injectSaga: Expected a valid saga descriptor',\r\n  );\r\n};\r\n\r\nexport function injectSagaFactory(store, isValid) {\r\n  return function injectSaga(key, descriptor = {}, args) {\r\n    if (!isValid) checkStore(store);\r\n\r\n    const newDescriptor = {\r\n      ...descriptor,\r\n      mode: descriptor.mode || DAEMON,\r\n    };\r\n    const { saga, mode } = newDescriptor;\r\n\r\n    checkKey(key);\r\n    checkDescriptor(newDescriptor);\r\n\r\n    let hasSaga = Reflect.has(store.injectedSagas, key);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      const oldDescriptor = store.injectedSagas[key];\r\n      // enable hot reloading of daemon and once-till-unmount sagas\r\n      if (hasSaga && oldDescriptor.saga !== saga) {\r\n        oldDescriptor.task.cancel();\r\n        hasSaga = false;\r\n      }\r\n    }\r\n\r\n    if (\r\n      !hasSaga ||\r\n      (hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT)\r\n    ) {\r\n      /* eslint-disable no-param-reassign */\r\n      store.injectedSagas[key] = {\r\n        ...newDescriptor,\r\n        task: store.runSaga(saga, args),\r\n      };\r\n      /* eslint-enable no-param-reassign */\r\n    }\r\n  };\r\n}\r\n\r\nexport function ejectSagaFactory(store, isValid) {\r\n  return function ejectSaga(key) {\r\n    if (!isValid) checkStore(store);\r\n\r\n    checkKey(key);\r\n\r\n    if (Reflect.has(store.injectedSagas, key)) {\r\n      const descriptor = store.injectedSagas[key];\r\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\r\n        descriptor.task.cancel();\r\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\r\n        if (process.env.NODE_ENV === 'production') {\r\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\r\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport default function getInjectors(store) {\r\n  checkStore(store);\r\n\r\n  return {\r\n    injectSaga: injectSagaFactory(store, true),\r\n    ejectSaga: ejectSagaFactory(store, true),\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}