{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Naveen\\\\Desktop\\\\Final\\\\FEEngineer_Assignment\\\\coding-test\\\\src\\\\utils\\\\injectSaga.js\";\nimport React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext } from 'react-redux';\nimport getInjectors from './sagaInjectors';\n/**\r\n * Dynamically injects a saga, passes component's props as saga arguments\r\n *\r\n * @param {string} key A key of the saga\r\n * @param {function} saga A root saga that will be injected\r\n * @param {string} [mode] By default (constants.DAEMON) the saga will be started\r\n * on component mount and never canceled or started again. Another two options:\r\n *   - constants.RESTART_ON_REMOUNT — the saga will be started on component mount and\r\n *   cancelled with `task.cancel()` on component unmount for improved performance,\r\n *   - constants.ONCE_TILL_UNMOUNT — behaves like 'RESTART_ON_REMOUNT' but never runs it again.\r\n *\r\n */\n\nexport default (({\n  key,\n  saga,\n  mode\n}) => WrappedComponent => {\n  class InjectSaga extends React.Component {\n    constructor(props, context) {\n      super(props, context);\n      this.injectors = getInjectors(context.store);\n      this.injectors.injectSaga(key, {\n        saga,\n        mode\n      }, this.props);\n    }\n\n    componentWillUnmount() {\n      this.injectors.ejectSaga(key);\n    }\n\n    render() {\n      return /*#__PURE__*/React.createElement(WrappedComponent, Object.assign({}, this.props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 42,\n          columnNumber: 14\n        }\n      }));\n    }\n\n  }\n\n  InjectSaga.WrappedComponent = WrappedComponent;\n  InjectSaga.contextType = ReactReduxContext;\n  InjectSaga.displayName = `withSaga(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`;\n  return hoistNonReactStatics(InjectSaga, WrappedComponent);\n});\n\nconst useInjectSaga = ({\n  key,\n  saga,\n  mode\n}) => {\n  const context = React.useContext(ReactReduxContext);\n  React.useEffect(() => {\n    const injectors = getInjectors(context.store);\n    injectors.injectSaga(key, {\n      saga,\n      mode\n    });\n    return () => {\n      injectors.ejectSaga(key);\n    };\n  }, []);\n};\n\nexport { useInjectSaga };","map":{"version":3,"sources":["C:/Users/Naveen/Desktop/Final/FEEngineer_Assignment/coding-test/src/utils/injectSaga.js"],"names":["React","hoistNonReactStatics","ReactReduxContext","getInjectors","key","saga","mode","WrappedComponent","InjectSaga","Component","constructor","props","context","injectors","store","injectSaga","componentWillUnmount","ejectSaga","render","contextType","displayName","name","useInjectSaga","useContext","useEffect"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,oBAAP,MAAiC,yBAAjC;AACA,SAASC,iBAAT,QAAkC,aAAlC;AAEA,OAAOC,YAAP,MAAyB,iBAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAe,CAAC;AAAEC,EAAAA,GAAF;AAAOC,EAAAA,IAAP;AAAaC,EAAAA;AAAb,CAAD,KAAyBC,gBAAgB,IAAI;AAC1D,QAAMC,UAAN,SAAyBR,KAAK,CAACS,SAA/B,CAAyC;AASvCC,IAAAA,WAAW,CAACC,KAAD,EAAQC,OAAR,EAAiB;AAC1B,YAAMD,KAAN,EAAaC,OAAb;AAEA,WAAKC,SAAL,GAAiBV,YAAY,CAACS,OAAO,CAACE,KAAT,CAA7B;AAEA,WAAKD,SAAL,CAAeE,UAAf,CAA0BX,GAA1B,EAA+B;AAAEC,QAAAA,IAAF;AAAQC,QAAAA;AAAR,OAA/B,EAA+C,KAAKK,KAApD;AACD;;AAEDK,IAAAA,oBAAoB,GAAG;AACrB,WAAKH,SAAL,CAAeI,SAAf,CAAyBb,GAAzB;AACD;;AAEDc,IAAAA,MAAM,GAAG;AACP,0BAAO,oBAAC,gBAAD,oBAAsB,KAAKP,KAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAP;AACD;;AAvBsC;;AAAnCH,EAAAA,UADoD,CAEjDD,gBAFiD,GAE9BA,gBAF8B;AACpDC,EAAAA,UADoD,CAIjDW,WAJiD,GAInCjB,iBAJmC;AACpDM,EAAAA,UADoD,CAMjDY,WANiD,GAMlC,YAAWb,gBAAgB,CAACa,WAAjB,IAC/Bb,gBAAgB,CAACc,IADc,IAE/B,WAAY,GAR0C;AA2B1D,SAAOpB,oBAAoB,CAACO,UAAD,EAAaD,gBAAb,CAA3B;AACD,CA5BD;;AA8BA,MAAMe,aAAa,GAAG,CAAC;AAAElB,EAAAA,GAAF;AAAOC,EAAAA,IAAP;AAAaC,EAAAA;AAAb,CAAD,KAAyB;AAC7C,QAAMM,OAAO,GAAGZ,KAAK,CAACuB,UAAN,CAAiBrB,iBAAjB,CAAhB;AACAF,EAAAA,KAAK,CAACwB,SAAN,CAAgB,MAAM;AACpB,UAAMX,SAAS,GAAGV,YAAY,CAACS,OAAO,CAACE,KAAT,CAA9B;AACAD,IAAAA,SAAS,CAACE,UAAV,CAAqBX,GAArB,EAA0B;AAAEC,MAAAA,IAAF;AAAQC,MAAAA;AAAR,KAA1B;AAEA,WAAO,MAAM;AACXO,MAAAA,SAAS,CAACI,SAAV,CAAoBb,GAApB;AACD,KAFD;AAGD,GAPD,EAOG,EAPH;AAQD,CAVD;;AAYA,SAASkB,aAAT","sourcesContent":["import React from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { ReactReduxContext } from 'react-redux';\r\n\r\nimport getInjectors from './sagaInjectors';\r\n\r\n/**\r\n * Dynamically injects a saga, passes component's props as saga arguments\r\n *\r\n * @param {string} key A key of the saga\r\n * @param {function} saga A root saga that will be injected\r\n * @param {string} [mode] By default (constants.DAEMON) the saga will be started\r\n * on component mount and never canceled or started again. Another two options:\r\n *   - constants.RESTART_ON_REMOUNT — the saga will be started on component mount and\r\n *   cancelled with `task.cancel()` on component unmount for improved performance,\r\n *   - constants.ONCE_TILL_UNMOUNT — behaves like 'RESTART_ON_REMOUNT' but never runs it again.\r\n *\r\n */\r\nexport default ({ key, saga, mode }) => WrappedComponent => {\r\n  class InjectSaga extends React.Component {\r\n    static WrappedComponent = WrappedComponent;\r\n\r\n    static contextType = ReactReduxContext;\r\n\r\n    static displayName = `withSaga(${WrappedComponent.displayName ||\r\n      WrappedComponent.name ||\r\n      'Component'})`;\r\n\r\n    constructor(props, context) {\r\n      super(props, context);\r\n\r\n      this.injectors = getInjectors(context.store);\r\n\r\n      this.injectors.injectSaga(key, { saga, mode }, this.props);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      this.injectors.ejectSaga(key);\r\n    }\r\n\r\n    render() {\r\n      return <WrappedComponent {...this.props} />;\r\n    }\r\n  }\r\n\r\n  return hoistNonReactStatics(InjectSaga, WrappedComponent);\r\n};\r\n\r\nconst useInjectSaga = ({ key, saga, mode }) => {\r\n  const context = React.useContext(ReactReduxContext);\r\n  React.useEffect(() => {\r\n    const injectors = getInjectors(context.store);\r\n    injectors.injectSaga(key, { saga, mode });\r\n\r\n    return () => {\r\n      injectors.ejectSaga(key);\r\n    };\r\n  }, []);\r\n};\r\n\r\nexport { useInjectSaga };\r\n"]},"metadata":{},"sourceType":"module"}